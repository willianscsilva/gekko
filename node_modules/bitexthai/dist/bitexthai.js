'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _querystring = require('querystring');

var _querystring2 = _interopRequireDefault(_querystring);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

module.exports = function () {
  function Bitexthai() {
    var key = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
    var secret = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
    var twofa = arguments.length <= 2 || arguments[2] === undefined ? '' : arguments[2];

    _classCallCheck(this, Bitexthai);

    this.key = key;
    this.secret = secret;
    this.twofa = twofa;
  }

  // internal method for making a REST call


  _createClass(Bitexthai, [{
    key: '_request',
    value: function _request(handler, options, data, callback) {
      var req = handler.request(options, function (res) {
        res.setEncoding('utf8');
        var buffer = '';
        res.on('data', function (data) {
          buffer += data;
        });
        res.on('end', function () {
          if (buffer === '401 Unauthorized\n') {
            return callback('General API error: 401 Unauthorized');
          }

          if (_lodash2.default.isEmpty(buffer)) {
            return callback('Bitexthai returned empty response');
          }

          var json = void 0;
          try {
            json = JSON.parse(buffer);
          } catch (err) {
            return callback(err);
          }

          if ('error' in json) {
            return callback('API error: ' + json.error);
          }

          return callback(null, json);
        });
      });
      req.on('error', function (err) {
        callback(err);
      });
      req.end(data);
    }

    // internal method for accessing the Public API
    //
    // https://bx.in.th/info/api

  }, {
    key: '_marketRequest',
    value: function _marketRequest(method, params, callback) {
      var options = {
        host: 'bx.in.th',
        path: '/api/' + method + '/?' + _querystring2.default.stringify(params),
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/4.0 (compatible; bx.in.th node.js client)'
        }
      };

      this._request(_https2.default, options, null, callback);
    }

    //
    // Public API calls
    //

  }, {
    key: 'ticker',
    value: function ticker(callback) {
      this._marketRequest('', {}, callback);
    }
  }, {
    key: 'pairings',
    value: function pairings(callback) {
      this._marketRequest('pairing', {}, callback);
    }
  }, {
    key: 'trades',
    value: function trades(pairing, callback) {
      if (!pairing) {
        pairing = 1;
      }
      this._marketRequest('trade', { pairing: pairing }, callback);
    }
  }, {
    key: 'historydata',
    value: function historydata(pairing, since, callback) {
      this._marketRequest('tradehistory', {
        pairing: pairing,
        date: since
      }, callback);
    }
  }, {
    key: 'orderbook',
    value: function orderbook(pairing, callback) {
      this._marketRequest('orderbook', { pairing: pairing }, callback);
    }

    // internal method for accessing the Private API
    //
    // https://bx.in.th/info/api/

  }, {
    key: '_tradeRequest',
    value: function _tradeRequest(method, params, callback) {
      if (!this.key || !this.secret) {
        throw 'Must provide key and secret to make Private API requests';
      }

      if (!_lodash2.default.isArray(params)) {
        throw 'Params need to be an array with parameters in the order ' + 'they are listed in the API docs.';
      }

      if (!_lodash2.default.isFunction(callback)) {
        callback = function callback() {};
      }

      var nonce = new Date() * 1000;
      var qs = this.key + '1465360716678899' + this.secret;

      var signer = _crypto2.default.createHash('sha256');
      var hmac = signer.update(qs).digest('hex');
      var signature = new Buffer(hmac).toString();

      var opts = Object.assign({}, {
        key: this.key,
        signature: signature,
        nonce: nonce
      }, params);

      if (this.twofa !== '') {
        opts.twofa = this.twofa;
      }

      var body = JSON.stringify(opts, null, 4);

      var options = {
        host: 'bx.in.th',
        path: '/api/' + method + '/?' + _querystring2.default.stringify(params),
        method: 'POST',
        headers: {
          'User-Agent': 'Mozilla/4.0 (compatible; Bitexthai node.js client)',
          'Content-Length': body.length
        }
      };

      this._request(_https2.default, options, body, callback);
    }

    //
    // Private API calls
    //

  }, {
    key: 'createOrder',
    value: function createOrder(pairing, type, amount, rate, callback) {
      this._tradeRequest('order', {
        pairing: pairing,
        type: type,
        amount: amount,
        rate: rate
      }, callback);
    }
  }, {
    key: 'cancelOrder',
    value: function cancelOrder(pairing, orderId, callback) {
      if (orderId.constructor === Array) {
        if (orderId.length > 10) {
          throw 'Current limit of orders per cancelation request is 10';
        }
        orderId = orderId.toString();
      }

      this._tradeRequest('cancel', {
        pairing: pairing,
        order_id: orderId
      }, callback);
    }
  }, {
    key: 'getBalances',
    value: function getBalances(callback) {
      this._tradeRequest('balance', {}, callback);
    }
  }, {
    key: 'getOrders',
    value: function getOrders() {
      var pairing = arguments.length <= 0 || arguments[0] === undefined ? -1 : arguments[0];
      var type = arguments.length <= 1 || arguments[1] === undefined ? 'hold' : arguments[1];
      var callback = arguments[2];

      var params = {};

      if (pairing !== -1) {
        params.pairing = pairing;
      }
      if (type !== 'hold') {
        params.type = type;
      }

      this._tradeRequest('getorders', params, callback);
    }
  }, {
    key: 'transactionHistory',
    value: function transactionHistory() {
      var currency = arguments.length <= 0 || arguments[0] === undefined ? 'BTC' : arguments[0];
      var type = arguments.length <= 1 || arguments[1] === undefined ? 'fee' : arguments[1];
      var startDate = arguments.length <= 2 || arguments[2] === undefined ? '2016-03-10 17:16:18' : arguments[2];
      var endDate = arguments.length <= 3 || arguments[3] === undefined ? '2016-03-11 17:16:18' : arguments[3];
      var callback = arguments[4];

      this._tradeRequest('history', {
        currency: currency,
        type: type,
        start_date: startDate,
        end_date: endDate
      }, callback);
    }
  }, {
    key: 'depositAddress',
    value: function depositAddress(currency) {
      var genNew = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
      var callback = arguments[2];

      this._tradeRequest('deposit', {
        currency: currency,
        new: genNew
      }, callback);
    }
  }, {
    key: 'requestWithdrawal',
    value: function requestWithdrawal(currency, amount, address) {
      var bank = arguments.length <= 3 || arguments[3] === undefined ? '' : arguments[3];
      var accName = arguments.length <= 4 || arguments[4] === undefined ? '' : arguments[4];
      var cb = arguments[5];

      var params = {
        currency: currency,
        amount: amount,
        address: address
      };

      if (bank !== '') {
        params.bank = bank;
      }
      if (accName !== '') {
        params.account_name = accName;
      }

      this._tradeRequest('withdrawal', params, cb);
    }
  }, {
    key: 'withdrawalHistory',
    value: function withdrawalHistory(openonly, callback) {
      this._tradeRequest('withdrawal-history', {}, callback);
    }
  }]);

  return Bitexthai;
}();